---
title: "Learning Social Media Analytics"
# subtitle: "<html><div style='float:left'></div><hr color='#EB811B' size=1px width=796px></html>"
subtitle: "Lecture 4: R syntax (refresher)"
author: "Luka Sikic, PhD"
date: "Faculty of Croatian Studies | [LSMA](https://lusiki.github.io/Learning-Social-Media-Analytics/)" #"`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document:
    code_folding: show
    theme: flatly
    highlight: haddock
    toc: yes
    toc_depth: 4
    toc_float: yes
    keep_md: yes
  pdf_document:
    toc: yes
    toc_depth: '4'
---



```{r knitr-opts,include=FALSE,purl=FALSE}
library(knitr)
prefix <- "tutorial"
opts_chunk$set(
  progress=TRUE,
  prompt=FALSE,tidy=FALSE,highlight=TRUE,
  strip.white=TRUE,
  warning=FALSE,
  message=FALSE,
  error=FALSE,
  echo=TRUE,
  cache=TRUE,
  cache.extra=rand_seed,
  results='markup',
  fig.show='asis',
  fig.height=4,
  fig.width=6.83,
  dpi=100,
  dev='png',
  dev.args=list(bg='transparent')
)
options(keep.source=TRUE,encoding="UTF-8")
```
```{r prelims,include=FALSE,purl=TRUE,cache=FALSE}
options(stringsAsFactors=FALSE)
```


```{r libs, include=TRUE, echo=FALSE,message=FALSE, warning=FALSE}
library(tidyverse)
library(readxl)
library(here)
library(kableExtra)
library(DT)
library(rvest)
library(tidyverse)
library(httr)
```


# BEFORE WE BEGIN


It is important to type code yourself---**type at your keyboard and see what happens on your screen**---to get the feel of working in **R**. 

Many other similar introductions are exist around the web.
This particular version has similar coverage to the standard [*Introduction to* ***R*** manual](https://cran.r-project.org/doc/manuals/r-release/R-intro.html) and targets students who are neither programmers nor statisticians (yet).



# WHAT IS **R** ?

**R** is a computing environment that combines: 

- a programming language called **S**, developed by John Chambers at Bell Labs, that implements the idea of *programming with data*,
- an extensive set of functions for classical and modern statistical data analysis and modeling,
- powerful numerical analysis tools for linear algebra, differential equations, and stochastics,
- graphics functions for visualizing data and model output, 
- a modular and extensible structure that supports a vast array of optional add-on packages, and
- extensive help and documentation facilities.

**R** is an [open source software project](https://en.wikipedia.org/wiki/Open-source_software), available for [free download](https://www.r-project.org/) [@R].
Originally a research project in statistical computing, it is now managed by a development team that includes a number of well-regarded statisticians, and is widely used by statistical researchers and working scientists as a platform for making new methods available to users.

There are a number of graphical front-ends (IDE) for **R**.
At present, the best of these appears to be [**RStudio**](http://www.rstudio.com).
Before learning about these, however, you should learn a little about **R** itself.



# GETTING STARTED WITH **R** 

## Installing **R** on your computer

The main source for **R** is the [Comprehensive R Archive Network (CRAN)](http://cran.r-project.org). 

You can get the source code and compile it yourself, but you may prefer at this point to download and install a precompiled version. 

You can download precompiled binaries for most major platforms from any CRAN mirror.
To do so, go to http://cran.r-project.org/mirrors.html and find a mirror site that is geographically somewhat near you.

Find the appropriate page for your operating system, and read and follow the installation instructions. **Be sure to install the latest version.**

**R** should work well on any reasonably recent computer.

Under Windows, **R** is installed by launching the downloaded file and following the on-screen instructions. 
At the end you'll have an **R** icon on your desktop that can be used to launch the program. 

Under Linux, binary versions of **R** are available as packages for the most common Linux distributions.
It is also not difficult to install **R** from source.

Under Mac OS X, **R** is available as a binary package.

The standard distributions of **R** include several *packages*: user-contributed suites of add-on functions.
These notes use some additional packages which you will have to install before using.
&#9420;&nbsp;In the Windows version additional packages can be installed easily from within **R** using the **Packages** menu.
Under all platforms, you can use the commands `install.packages()` and `update.packages()` to install and update packages, respectively.
Most packages are available pre-compiled for MacOS X and Windows;
under Linux, **R** will download and compile the source code for you.

## Starting **R** 

Execute `R` on the command line.

Click on the icon on your desktop, or in the `Start` menu (if you allowed the Setup program to make either or both of these).

## Stopping **R** 

Stop **R** by typing `q()` at the command prompt.
[Note the `()`: if you type `q` by itself, you will get some confusing output which is actually **R** trying to tell you the definition of the `q` function;
more on this later.]

You can also stop **R** from the `File` menu.

When you quit, **R** will ask you if you want to save the workspace (that is, all of the variables you have defined in this session); 
in general, you should say "no" to avoid clutter and unintentional confusion of results from different sessions.
**Note:**  When you say "yes" to saving your workspace, it is saved in a hidden file named `.RData`.
By default, when you open a new **R** session in the same directory, this workspace is loaded and a message informing you so is printed:

```
[Previously saved workspace restored]
```

Should an **R** command seem to be stuck or take longer than you're willing to wait, click on the stop sign on the menu bar or hit the `Esc` key (&#9420;), or `Ctrl-c` (&#9421;).


# INTERACTIVE CALCULATIONS

When you start **R**, a console window is opened.
The console has a few basic menus at the top; check them out on your own. 

The console is where you enter commands for **R** to execute *interactively*, meaning that the command is executed and the result is displayed as soon as you hit the ` Enter` key. 
For example, at the command prompt `>`, type in `2+2` and hit `Enter`; you will see 
```{r }
2+2 
```

The results from calculations can be stored in (*assigned to*) variables. 
For example:
```{r }
a <- 2+2
```
**R** automatically creates the variable `a` and stores the result (`r a`) in it, but by default doesn't print anything.
To ask **R** to print the value, just type the variable name by itself
```{r}
a
```
The `[1]` at the beginning of the line is just **R** printing an index of element numbers;
if you print a result that displays on multiple lines, **R** will put an index at the beginning of each line.

`print(a)` also works to print the value of a variable.
By default, a variable created this way is a *vector* (an ordered list), and it is *numeric* because we gave **R** a number rather than (e.g.) a character string like `"pxqr"`;
in this case `a` is a numeric vector of length 1;

You could also type
```
a <- 2+2; a
```
using a semicolon to put two or more commands on a single line.
Conversely, you can break lines *anywhere that* **R** *can tell you haven't finished your command* and **R** will give you a "continuation" prompt (`+`) to let you know that it doesn't think you're finished yet: try typing
```
a <- 3*(4+
5)
```
to see what happens (this often happens e.g. if you forget to close parentheses or quotes).
If you get stuck continuing a command you don't want---e.g., you opened the wrong parentheses---just hit `Ctrl-c`, the `Esc` key or the stop icon in the menu bar to get out.

You can assign values to variables in **R** using the `<-` operator.
There are several alternative forms for assignment.
Each of these three commands accomplishes the same thing;
the first is the preferred form, however.
```
a <- 2+2
2+2 -> a
a = 2+2
```

Variable names in **R** must begin with a letter, followed by alphanumeric characters. 
You can break up long names with a period, as in `long.variable.number.3`, an underscore (`very_very_long_variable_name`), or by using camel case (`quiteLongVariableName`); 
you cannot use blank spaces in variable names. 
**R** is case sensitive:
`Abc` and `abc` are different variables.
Good practice is to make variable names long enough to be evocative but short enough to type easily.
`N.per.ha` or `pop.density` are better than `x` and `y` (too generic) or `available.nitrogen.per.hectare` (too long).

Note that `c`, `q`, `t`, `C`, `D`, `F`, `I`, and `T`, are built-in **R** functions.
Using these are variable names may cause confusion or actual errors.

**R** uses `+`, `-`, `*`, `/`, and `^` for addition, subtraction, multiplication, division and exponentiation, respectively.
For example:
```{r }
x <- 5
y <- 2
z1 <- x*y
z2 <- x/y
z3 <- x^y
z1; z2; z3
``` 

You can retrieve and edit previous commands. 
The up-arrow (\thinspace $\uparrow$ \thinspace) key or `Ctrl-p` recalls previous commands to the prompt. 
For example, you can bring back the second-to-last command and edit it to
```{r }
z3 <- 2*x^y
``` 
Experiment with the $\downarrow$, $\rightarrow$, $\leftarrow$, `Home` and `End` keys too (also `Ctrl-n`, `Ctrl-b`, `Ctrl-f`, `Ctrl-a`, `Ctrl-e`).

You can combine several operations in one calculation:
```{r }
A <- 3
C <- (A+2*sqrt(A))/(A+5*sqrt(A)); C
``` 

Parentheses specify the order of operations. 
The command
```{r }
C <- A+2*sqrt(A)/A+5*sqrt(A)
``` 
is not the same as the one above;
rather, it is equivalent to 
```{r eval=FALSE}
C <- A + 2*(sqrt(A)/A) + 5*sqrt(A)
``` 
The default order of operations is:
(1) parentheses,
(2) exponentiation,
(3) multiplication and division,
(4) addition and subtraction.
Thus:

`> b <- 12-4/2^3`  ***gives***  `12 - 4/8 = 12 - 0.5 = 11.5`  
`> b <- (12-4)/2^3` ***gives*** `8/8 = 1`  
`> b <- -1^2`   ***gives***  `-(1^2) = -1`  
`> b <- (-1)^2` ***gives***  `1`  

In complicated expressions it's best to **use parentheses to specify explicitly what you want**, such as ` > b <- 12 - (4/(2^3)) ` or at least ` > b <- 12 - 4/(2^3) `; 
a few extra sets of parentheses never hurt anything.

Some of the built-in mathematical functions in **R**.

**R** command             | function
-----------------         | ------------------------------
`abs()`                   | absolute value, $|x|$
`cos()`, `sin()`, `tan()` | cosine, sine, tangent
`acos()`, `asin()`, `atan()` | arc-cosine, arc-sine, arc-tangent
`exp(x)`     | exponential function, $e^x$
`log(x)`     | natural (base-$e$) logarithm, $\log{x}=\ln{x}$
`log10(x)`   | base-10 logarithm, $\log_{10}{x}$
`sqrt(x)`    | square root, $\sqrt{x}$
`atan2(y,x)` | $\arctan(y/x)$
`sum()`      | sum of the entries in a vector
`diff()`     | first differences
`cumsum()`   | cumulative sum
`gamma(x)`   | the Gamma function, $\Gamma(x)$


You can get a more complete list of functions from the help system (check below): 
`?Arithmetic` for arithmetic operations, `?log` for logarithmic functions, `?sin` for trigonometric functions, and `?Special` for special functions.



# THE HELP SYSTEM

**R** has a help system, although it is generally better for reminding you about syntax or details, and for giving cross-references, than for answering basic "how do I ...?" questions.

- You can get help on an **R** function named `foo` by entering
```{r eval=FALSE}
?foo
```
or
```{r eval=FALSE}
help(foo)
```
into the console window (e.g., try `?sin`). 

By default, **R** 's help system only provides information about functions that are in the base system and packages that you have already loaded (see below).

- `??topic` or `help.search("topic")` will list information related to `topic` available in the base system or in any extra installed packages:
then use `?topic` to see the information, perhaps using
`library(pkg)` to load the appropriate package first.
- `help.search` uses fuzzy matching---for example, `help.search("log")` finds more than 800 entries (on my particular system) including lots of functions with "plot", which includes the letters "lot", which are *almost* like "log".
If you can't stand it, you can turn this behavior off with the incantation `help.search("log",agrep=FALSE)` (81 results which still include matches for "logistic", "myelogenous", "phylogeny", \dots).
- `help(package="pkg")` will list all the help pages for a loaded package.
- `example(fun)` will run the examples (if any) given in the help for a particular function `fun`: e.g., `example(log)`
- `RSiteSearch("topic")` does a full-text search of all the **R** documentation and the mailing list archives for information on `topic` (you need an active internet connection).
- the `sos` package is a web-aware help function that searches all of the packages on CRAN; its `findFn` function tries to find and organize functions in any package on CRAN that match a search string (again, you need a network connection for this).

Try out one or more of these aspects of the help system.


# INTERACTIVE SESSION

## Descriptive statistics

Below are some data on the maximum growth rate $r_{\text{max}}$ of laboratory populations of the green alga *Chlorella vulgaris* as a function of light intensity ($\mu\mathrm{E}~\mathrm{m}^{-2}~\mathrm{s}^{-1}$).

| 
------|------------------------------------------------------
Light: | 20,  20,  20,  20,  21,  24,  44,  60,  90,  94, 101
$r_{\text{max}}$: | 1.73, 1.65, 2.02, 1.89, 2.61, 1.36, 2.37, 2.08, 2.69, 2.32, 3.67


To analyze these data in **R** , first enter them as numerical *vectors*: 
```{r }
Light <- c(20,20,20,20,21,24,44,60,90,94,101)
rmax <- c(1.73,1.65,2.02,1.89,2.61,1.36,2.37,2.08,2.69,2.32,3.67)
``` 

The function `c()` *combines* the individual numbers into a vector.
Try recalling (with $\uparrow$) and modifying the above command to 
```{r eval=FALSE}
Light <- 20,20,20,20,21,24,44,60,90,94,101
``` 
and see the error message you get: 
in order to create a vector of specified numbers, you must use the `c()` function.

To see a histogram of the growth rates enter `hist(rmax)`, which opens a graphics window and displays the histogram. 
There are **many** other built-in statistics functions in **R**.
Some of the most commonly used are shown in the table below.
Play around with these functions, and any others you can think of.

---------------------------

| 
--------------------|------------------------------------
`mean(x)`           | the arithmetic mean of the data in `x`
`exp(mean(log(x)))` | the geometric mean of `x`
`1/mean(1/x)`       | the harmonic mean of `x`
`median(x)`         | the median of `x`
`min(x)`, `max(x)`  | the minimum and maximum, respectively, of `x`
`range(x)`          | the range of `x`
`sd(x)`             | the standard deviation of `x`
`var(x)`            | the variance of `x`
`quantile(x, p)`    | the `p`-th quantiles of `x`
`ecdf(x)`        | the empirical cumulative distribution function of `x`

Table: Some simple descriptive statistics in **R**

---------------------------

To see how the algal rate of increase varies with light intensity, type
```{r chlorella-plot,eval=FALSE}
plot(rmax~Light)
``` 
to plot `rmax` ($y$) against `Light` ($x$).
You can also do `plot(Light,rmax)`.
Based on what you see, does it seem reasonable to hypothesize a linear relationship between these variables?

## Linear regression

To perform linear regression we create a linear model using the `lm()` function:
```{r}
fit <- lm(rmax~Light)
``` 
In the formula `rmax~Light`, `rmax` is the response variable and `Light` is the predictor.

The `lm` command created an *object* we have named `fit`.
In **R** , an *object* is a data structure consisting of multiple parts.
In this case, `fit` holds the results of the linear regression analysis. 
Unlike other statistics packages, **R** rarely summarizes an analysis for you by default.
Statistical analyses in **R** are done by fitting a model to data and then issuing additional commands to extract desired information about the model or display results graphically.

To get a summary of the results, enter the command `summary(fit)`. 
**R** sets up model objects (more on this later) so that the function `summary()` "knows" that `fit` was created by `lm()`, and produces an appropriate summary of results for an `lm()` object: 
```{r}
summary(fit)
``` 

If you've had a statistics course, the output will make sense to you. 
The table of coefficients gives the estimated regression line as
$$\text{rmax}=`r signif(coef(fit)[1],3)`+`r signif(coef(fit)[2],3)`\times\text{Light}.$$
Associated with each coefficient is the standard error of the estimate.
In addition, for each coefficient, a $t$-test is performed testing the hypothesis that the coefficient differs from zero:
the $t$-statistic and the corresponding $p$-values are reported.
Finally, the summary reports $R^2$ values and the results of an $F$-test comparing the model to a simple normal null hypothesis.

You can add the regression line to the plot of the data with a function taking `fit` as its input (if you closed the plot of the data, you will need to create it again in order to add the regression line):
```{r eval=FALSE}
abline(fit)
```
[`abline` is a general-purpose function for adding lines to a plot.
You can specify horizontal or vertical lines, a slope and an intercept, or a regression model: `?abline`.] 

```{r echo=FALSE}
plot(rmax~Light,main="Graphical summary of regression analysis")
abline(fit)
```  

You can extract the coefficients from the fitted model using `coef`:

```{r }
coef(fit)
``` 

There are many other results stored inside `fit`.
Try the following:

```{r eval=FALSE}
residuals(fit)
fitted(fit)
effects(fit)
vcov(fit)
anova(fit)
```

# Statistics in **R** 

Some of the important functions and packages (collections of functions) for statistical modeling and data analysis are summarized in following table.
Functions are named in `fixed-width font` and packages in **bold face**.
The book *Modern Applied Statistics with S* gives a good practical overview, and a list of available packages and their contents can be found at the main **R** website (http://cran.r-project.org, and click on `Packages`). 

A few of the functions and packages in **R** for statistical modeling and data analysis are listed below.
There are *many* more, but you will have to learn about them somewhere else.

-------------------------------

&nbsp;   | &nbsp;
--------------------------|------------------------
`aov`, `anova`            | Analysis of variance or deviance
`lm`                      | Linear models (regression, ANOVA, ANCOVA) 
`glm`                     | Generalized linear models (e.g. logistic, Poisson regression) 
`gam`                     | Generalized additive models (in package **mgcv**) 
`nls`                     | Nonlinear models via least-squares
`lme`, `nlme`             | Linear and nonlinear mixed-effects models (repeated measures, block effects, spatial models): in package **nlme** 
`princomp`, `manova`, `lda`, `cancor`  | Multivariate analysis (see also packages **vegan**, **ade4**)
**boot**                    | Package: bootstrapping functions 
**splines**                 | Package: nonparametric regression (more in packages **fields**, **KernSmooth**, **logspline**, **sm** and others)
**survival**                | Package: survival analysis 
**tree**, **rpart**         | Package: tree-based regression

Table: Statistical modeling and data analysis functions and packages.

-------------------------------


# THE **R** PACKAGE SYSTEM

**R** has many extra packages that provide extra functions.
You may be able to install new packages from a menu within **R**. 
You can always type, e.g.,
```{r eval=FALSE}
install.packages("ggplot2")
```
This installs the **ggplot2** package.
You can install more than one package at a time:
```{r eval=FALSE}
install.packages(c("plyr","reshape2"))
```
If the machine on which you use **R** is not connected to the Internet, you can download the packages to some other medium (such as a flash drive or CD)
and install them later, using `Install from local zip file` in the menu (&#9420;) or
```{r eval=FALSE}
install.packages("ggplot2",repos=NULL)
``` 

If you do not have permission to install packages in **R** 's central directory, **R** will may ask whether you want to install the packages in a user-specific directory.
It is safe to answer "yes" here.

You will frequently get a warning message like
```
Warning message: In file.create(f.tg) :
cannot create file '.../packages.html', reason 'Permission denied'.
```
Don't worry about this;
it means the package has been installed successfully, but the main help system index files couldn't be updated because of file permissions problems.


# DATA STRUCTURES IN **R**

## Vectors 

The most basic data-type in **R** is the vector.
A vector is just a 1-dimensional array of values.
Several different kinds of vectors are available:

- numerical vectors,
- logical vectors,
- character-string vectors,
- factors,
- ordered factors, and
- lists.

Lists are a bit different from the other kinds, so we'll postpone talking about them until later.

A vector's defining attributes are its *mode*---which kind of vector it is--- and its **length**.
Vectors can also have a `names` attribute, which allows one to refer to elements by name.

We've already seen how to create vectors in **R** using the `c` function, e.g.,
```{r }
x <- c(1,3,5,7,9,11)
y <- c(6.5,4.3,9.1,-8.5,0,3.6)
z <- c("dog","cat","dormouse","chinchilla")
w <- c(a=4,b=5.5,c=8.8)

length(x)
mode(y)
mode(z)
names(w)
``` 

The nice thing about having vectors as a basic type is that many operations in **R** are efficiently *vectorized*.
That is, the operation acts on the vector as a unit, saving you the trouble of treating each entry individually.
For example:
```{r}
x <- x+1
xx <- sqrt(x)
x; xx
``` 

Notice that the operations were applied to every entry in the vector. 
Similarly, commands like `x-5, 2*x, x/10`, and `x^2` apply subtraction, multiplication, division, and square to each element of the vector. 
The same is true for operations involving multiple vectors:

```{r}
x+y
```

In **R** the default is to apply functions and operations to vectors
in an *element by element* manner; 
anything else (e.g. matrix multiplication) is done using special notation (discussed below). 

### Element recycling

**R** has a very useful, but unusual and perhaps unexpected, behavior when two vector operands in a vectorized operation are of unequal lengths.
It will effectively extend the shorter vector using element "re-cycling": 
re-using elements of the shorter vector.
Thus
```{r}
x <- c(1,2,3)
y <- c(10,20,30,40,50,60)
x+y
y-x
``` 

### Functions for creating vectors

A set of regularly spaced values can be created with the `seq` function, whose syntax is `x <- seq(from,to,by)` or `x <- seq(from,to)` or `x <- seq(from,to,length.out)`.
The first form generates a vector `(from,from+by,from+2*by,...)` with the last entry not extending further than `to`;
in the second form the value of `by` is assumed to be 1 or -1, depending on whether `from` or `to` is larger; 
and the third form creates a vector with the desired endpoints and length.
There is also a shortcut for creating vectors with `by=1`:
```{r }
1:8
```



A constant vector such as `(1 1 1 1)` can be created with `rep` function, whose basic syntax is `rep(values,lengths)`.  
For example,
```{r }
rep(3,5)
``` 
creates a vector in which the value 3 is repeated 5 times. 
`rep()` will repeat a whole vector multiple times
```{r }
rep(1:3,3)
```
or will repeat each of the elements in a vector a given number of times:
```{r }
rep(1:3,each=3)
```
Even more flexibly, you can repeat each element in the vector a different number of times:
```{r }
rep(c(3,4),c(2,5))
``` 
The value 3 was repeated 2 times, followed by the value 4 repeated 5 times.
`rep()` can be a little bit mind-blowing as you get started, but you'll get used to it---and it will turn out to be useful.


-----------------------------------

|
----------------------------|-----------------------------------
`seq(from,to,by=1)`         | Vector of evenly spaced values (default increment = 1) 
`seq(from,to,length.out)`   | Vector of evenly spaced values, specified length 
`c(u,v,...) `               | Combine a set of numbers and/or vectors into a single vector 
`rep(a,b)`                  | Create vector by repeating elements of `a` `b` times each
`hist(v)`                   | Histogram plot of value in v 
`mean(v),var(v),sd(v)`      | Estimate of population mean, variance, standard deviation based on data values in `v` 
`cov(v,w)`                  | Covariance between two vectors 
`cor(v,w)`                  | Correlation between two vectors 

Table: Some important **R** functions for creating and working with vectors.

Many of these have other optional arguments; use the help system (e.g. `?cor`) for more information. 
The statistical functions such as `var` regard the values as samples from a population and compute the unbiased estimate of the population statistic; 
for example `sd(1:3)=1`.

-----------------------------------

### Vector indexing

It is often necessary to extract a specific entry or other part of a vector. 
This procedure is called *vector indexing*, and uses square brackets ([]):
```{r }
z <- c(1,3,5,7,9,11); z[3]
``` 
`z[3]` extracts the third element of the vector `z`. 
You can also access a block of elements by giving a vector of indices:
```{r }
v <- z[c(2,3,4,5)]
``` 
or
```{r }
v <- z[2:5]; v
``` 
This has extracted the 2nd through 5th elements in the vector. 

Extracted parts of a vector don't have to be regularly spaced. For example
```{r }
v <- z[c(1,2,5)]; v
``` 

Indexing is also used to **set specific values within a vector**. 
For example, 
```{r }
z[1] <- 12
``` 
changes the value of the first entry in `z` while leaving all the rest alone, and 
```{r }
z[c(1,3,5)] <- c(22,33,44)
``` 
changes the 1st, 3rd, and 5th values.

Elements in a named vector can be accessed and modified by name as well as by position.
Thus
```{r }
w
w["a"]
w[c("c","b")]
w["b"] <- 0
w
```

ou may be wondering if vectors in **R** are row vectors or column vectors (if you don't know what those are, don't worry).
The answer is "both and neither".
Vectors are printed out as row vectors, but if you use a vector in an operation that succeeds or fails depending on the vector's orientation, **R** will assume that you want the operation to succeed and will proceed as if the vector has the necessary orientation.
For example, **R** will let you add a vector of length 5 to a $5 \times 1$ matrix or to a $1 \times 5$ matrix, in either case yielding a matrix of the same dimensions.


### Logical operations

Some operations return a logical value (i.e., `TRUE` or `FALSE`). 
For example, try:

```{r }
a <- 1; b <- 3; 
c <- a < b
d <- (a > b)
c; d
``` 

The parentheses around `a > b` above are optional but do make the code easier to read.
Be careful when you make comparisons with negative values:
`a<-1` may surprise you by setting `a` to 1, because `<-` is the assignment operator in **R**.
Use `a< -1` or `a<(-1)` to make this comparison.

-----------------------------------

**R** code | comparison
---------|-----------------------------------
`x < y`  | $x$ strictly less than $y$
`x > y`  | $x$ strictly greater than $y$
`x <= y` | $x$ less than or equal to $y$
`x >= y` | $x$ greater than or equal to $y$
`x == y` | $x$ equal to $y$
`x != y` | $x$ *not* equal to $y$
`identical(x,y)` | $x$ completely identical to $y$
`all.equal(x,y)` | $x$ pretty much equal to $y$

Table: Some comparison operators in **R**. Use `?Comparison` to learn more.

-----------------------------------

When we compare two vectors or matrices, comparisons are done element-by-element (and the recycling rule applies).
For example,
```{r }
x <- 1:5; b <- (x<=3); b
``` 
So if `x` and `y` are vectors, then `(x==y)` will return a vector of values giving the element-by-element comparisons. 
If you want to know whether `x` and `y` are identical vectors, use `identical(x,y)` or `all.equal(x,y)`. 
You can use `?Logical` to read more about logical operations. 
**Note the difference between = and ==.**
**Can you figure out what happened in the following cautionary tale?**
```{r }
a=1:3
b=2:4
a==b
a=b
a==b
```

**R** can also do arithmetic on logical values, treating `TRUE` as 1 and `FALSE` as 0.
So `sum(x<3)` returns the value 2, telling us that two entries of `x` satisfied the condition (`x<3`). 
This is useful for counting the number of elements of a vector that satisfy a given condition.

More complicated conditions are built by using **logical operators** to combine comparisons.
The most important of these are tabulated here.

-----------------------------------

operator  | meaning
----------|--------------
`!`       |   logical NOT
`&`       |   logical AND, elementwise
`&&`      |  logical AND, first element only
`|`       |   logical OR, elementwise 
`||`      |  logical OR, first element only 
`xor(x,y)`| exclusive OR, elementwise

Table: Logical operators.

-----------------------------------

For example, try
```{r}
a <- c(1,2,3,4)
b <- c(1,1,5,5)
(a<b) | (a>3)
(a<b) || (a>3)
```
and make sure you understand what happened. 

The two forms of logical OR (`|`and `||`) are *inclusive*, meaning that `x|y` is true if either `x` or `y` or both are true. 
Use `xor` when exclusive OR is needed.
The two forms of AND and OR differ in how they handle vectors. 
The shorter one (`|`, `&`) does element-by-element comparisons; 
the longer one (`||`, `&&`) looks only at the first element in each vector. 

### More on vector indexing 

We can also use *logical* vectors (lists of `TRUE` and `FALSE` values) to pick elements out of vectors.
This is useful, for example, in subsetting data.

As a simple example, we might want to focus on just the low-light values of $r_{\text{max}}$ in the *Chlorella* example:
```{r fetch-chlorella-data,include=FALSE}
course.url <- "http://kingaa.github.io/R_Tutorial/"
X <- read.csv(paste0(course.url,"ChlorellaGrowth.csv"),comment.char='#')
Light <- X[,1]
rmax <- X[,2];
```


```{r }
lowLight <- Light[Light<50]
lowLightrmax <- rmax[Light<50]
lowLight
lowLightrmax
```

What is really happening here (think about it for a minute) is that `Light<50` generates a logical vector the same length as `Light` (`TRUE TRUE TRUE ...`) which is then used to select the appropriate values.

If you want the positions at which `Light` is lower than 50, you can use `which`: `which(Light<50)`.
If you wanted the position at which the maximum value of `Light` occurs, you could say `which(Light==max(Light))` or `which.max(Light)`.
Note that, if `Light` has several elements that are maximal, the first will return the positions of them all, while the second will return the position only of the *first* one.


## Matrices and arrays

### Creating matrices

A matrix is a two-dimensional array of items.
Most straightforwardly, we can create a matrix by specifying the number of rows and columns, and specifying the entries.
For example 
```{r }
X <- matrix(c(1,2,3,4,5,6),nrow=2,ncol=3); X
``` 
takes the values 1 to 6 and reshapes them into a 2 by 3 matrix. 
Note that the values in the data vector are put into the matrix *column-wise*, by default.
You can change this by using the optional parameter `byrow`: 
```{r }
A <- matrix(1:9,nrow=3,ncol=3,byrow=TRUE); A
``` 

**R** will re-cycle through entries in the data vector, if need be, to fill a matrix of the specified size. 
So for example 
```{r eval=F}
matrix(1,nrow=50,ncol=50)
``` 
creates a $50{\times}50$ matrix, every entry of which is $1$.

**R** will also cause a matrix to behave like a vector whenever it makes sense: 
for example `sum(X)` above is `r sum(X)`.

Another useful function for creating matrices is `diag`.
`diag(v,n)` creates an $n{\times}n$ matrix with data vector $v$ on its diagonal. 
So for example `diag(1,5)` creates the $5{\times}5$ *identity matrix*, which has 1s on the diagonal and 0 everywhere else.

Finally, one can use the `data.entry` function. 
This function can only edit existing matrices, but for example (try this now!)
```{r eval=F}
A <- matrix(0,3,4)
data.entry(A)
``` 
will create `A` as a $3{\times}4$ matrix, and then call up a spreadsheet-like interface in which the values can be edited directly.
You can further modify `A` with the same primitive interface, using `fix`.

-----------------------------------

**R** code                | purpose
--------------------------|---------------------------------------------
`matrix(v,nrow=m,ncol=n)` | $m \times n$ matrix using the values in `v` 
`t(A)`                    | transpose (exchange rows and columns) of matrix `A` 
`dim(X)`                  | dimensions of matrix X. `dim(X)[1]`=\# rows, `dim(X)[2]`=\# columns 
`data.entry(A)`           | call up a spreadsheet-like interface to edit the values in `A` 
`diag(v,n)`               | diagonal $n \times n$ matrix with $v$ on diagonal, 0 elsewhere (`v` is 1 by default, so `diag(n)` gives an $n \times n$ identity matrix)
`cbind(a,b,c,...)`        | combine compatible objects by attaching them along columns 
`rbind(a,b,c,...)`        | combine compatible objects by attaching them along rows 
`as.matrix(x)`            | convert an object of some other type to a matrix, if possible 
`outer(v,w)`              | "outer product" of vectors `v`, `w`: the matrix whose $(i,j)$-th element is `v[i]*w[j]` 

Table: Some important functions for creating and working with matrices.

Many of these functions have additional optional arguments;
use the help system for full details.

-----------------------------------

### `cbind` and `rbind` 

If their sizes match, vectors can be combined to form matrices, and matrices can be combined with vectors or matrices to form other matrices. 
The functions that do this are `cbind` and `rbind`. 

`cbind` binds together columns of two objects. 
One thing it can do is put vectors together to form a matrix: 
```{r }
C <- cbind(1:3,4:6,5:7); C
``` 
Remember that **R** interprets vectors as row or column vectors according to what you're doing with them. 
Here it treats them as column vectors so that columns exist to be bound together. 
On the other hand, 
```{r }
D <- rbind(1:3,4:6); D
``` 
treats them as rows. 
Now we have two matrices that can be combined. 

-----------------------------------


## Matrix indexing

Matrix indexing is like vector indexing except that you have to specify both the row and column, or range of rows and columns. 
For example `z <- A[2,3]` sets `z` equal to 6, which is the (2^nd^ row, 3^rd^ column) entry of the matrix **A** that you recently created, and 
```{r }
A[2,2:3]; 
B <- A[2:3,1:2]; B
``` 

There is an easy shortcut to extract entire rows or columns: leave out the limits, leaving a blank before or after the comma.
```{r }
first.row <- A[1,]; first.row
second.column <- A[,2]; second.column;
``` 

(What does `A[,]` do?)

As with vectors, indexing also works in reverse for assigning values to matrix entries. 
For example,
```{r }
A[1,1] <- 12; A
``` 

The same can be done with blocks, rows, or columns, for example
```{r }
A[1,] <- c(2,4,5); A
``` 

If you use `which()` on a matrix, **R** will normally treat the matrix as a vector---so for example `which(A==8)` will give the answer 6 (can you see why?).
However, `which()` does have an option that will treat its argument as a matrix:
```{r }
which(A>=8,arr.ind=TRUE)
``` 

## Arrays

The generalization of the matrix to more (or less) than 2 dimensions is the array.
In fact, in **R** , a matrix is nothing other than a 2-dimensional array.
How does **R** store arrays?
In the simplest possible way: an array is just a vector plus information on the dimensions of the array.
Most straightforwardly, we can create an array from a vector:

```{r}
X <- array(1:24,dim=c(3,4,2)); X
``` 

Note, again, that the arrays are filled in a particular order: the first dimension first, then the second, and so on.
A one-dimensional array is subtly different from a vector:
```{r }
y <- 1:5; y
z <- array(1:5,dim=5); z
y==z
identical(y,z)
dim(y); dim(z)
``` 


## Factors

For dealing with measurements on the nominal and ordinal scales [@Stevens1946], **R** provides vectors of type *factor*.
A factor is a variable that can take one of a finite number of distinct *levels*.
To construct a factor, we can apply the `factor` function to a vector of any class:
```{r }
x <- rep(c(1,2),each=3); factor(x)
trochee <- c("jetpack","ferret","pizza","lawyer")
trochee <- factor(trochee); trochee
``` 
By default, `factor` sets the levels to the unique set of values taken by the vector.
To modify that behavior, there is the `levels` argument:
```{r }
factor(trochee,levels=c("ferret","pizza","cowboy","scrapple"))
``` 
Note that the order of the levels is arbitrary, in keeping with the fact that the only operation permissible on the nominal scale is the test for equality.
In particular, the factors created with the `factor` command are un-ordered: there is no sense in which we can ask whether, e.g., `ferret < cowboy`.

To represent variables measured on the ordinal scale, **R** provides *ordered factors*, constructed via the `ordered` function.
An ordered factor is just like an un-ordered factor except that the order of the levels matters:
```{r echo=F}
set.seed(349585885L)
``` 
```{r }
x <- ordered(sample(x=letters,size=22,replace=TRUE)); x
``` 
Here, we've relied on `ordered`'s default behavior, which is to put the levels in alphabetical order.
It's typically safer to specify explicitly what order we want:
```{r }
x <- ordered(x,levels=rev(letters))
x[1:5] < x[18:22]
``` 

----------------------------


